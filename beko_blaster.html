<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Beko Space Shooter</title>
<style>
  :root {
    --bg: #0b0f1a;
    --panel: #0f1530;
    --text: #e8ecff;
    --acc: #6cf;
    --acc2: #ffb347;
    --danger: #ff5d73;
    --ok: #71ffb2;
  }
  * { box-sizing: border-box; }
  html, body {
    margin: 0;
    height: 100%;
    background: radial-gradient(1200px 600px at 50% -200px, #101736, var(--bg));
    color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
  }
  .wrap {
    display: grid;
    grid-template-rows: auto 1fr auto;
    height: 100%;
  }
  header, footer {
    background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,0));
    padding: .5rem 1rem;
  }
  header {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    align-items: center;
    gap: 1rem;
  }
  header h1 {
    margin: 0;
    font-size: 1rem;
    letter-spacing: .08em;
    opacity: .8;
  }
  .stats {
    justify-self: center;
    display: inline-grid;
    grid-auto-flow: column;
    gap: 1rem;
    align-items: center;
    font-variant-numeric: tabular-nums;
  }
  .stats span { opacity: .9; }
  .badges { justify-self: end; display: flex; gap: .5rem; }
  .badge {
    padding: .2rem .5rem;
    border: 1px solid rgba(255,255,255,.15);
    border-radius: .4rem;
    font-size: .8rem;
    opacity: .8;
  }
  #game {
    display: grid;
    place-items: center;
    padding: .5rem;
  }
  canvas {
    width: min(95vw, 800px);
    height: calc(min(95vw, 800px) * 0.625); /* maintain 1280x800 aspect */
    max-height: 85vh;
    border-radius: 12px;
    background:
      radial-gradient(800px 400px at 50% -50px, rgba(255,255,255,.06), transparent 60%),
      radial-gradient(1000px 600px at 50% 120%, rgba(255,255,255,.04), transparent 60%),
      #060912;
    box-shadow: 0 10px 40px rgba(0,0,0,.5), inset 0 0 0 1px rgba(255,255,255,.05);
    image-rendering: pixelated;
    touch-action: none; /* prevent scroll on touch controls */
  }
  footer {
    display: grid;
    gap: .5rem;
  }
  .controls {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    gap: .5rem;
    max-width: 800px;
    margin: 0 auto .5rem;
    user-select: none;
  }
  .btn {
    background: var(--panel);
    border: 1px solid rgba(255,255,255,.15);
    border-radius: 10px;
    padding: .6rem .9rem;
    text-align: center;
    font-weight: 600;
    letter-spacing: .04em;
    cursor: pointer;
    transition: transform .05s ease, background .2s ease;
  }
  .btn:active { transform: translateY(1px) scale(0.99); }
  .btn.secondary { opacity: .8; }
  .touch-pad {
    display: grid;
    grid-template-columns: repeat(3, 56px);
    grid-template-rows: repeat(2, 56px);
    gap: 8px;
    justify-content: start;
  }
  .touch-pad .btn { width: 56px; height: 56px; padding: 0; display: grid; place-items: center; }
  .right { justify-self: end; }
  .hint { text-align: center; opacity: .75; font-size: .9rem; }
  @media (min-width: 760px) {
    .touch-pad { display: none; }
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>BEKO REDUX SHOOTER</h1>
    <div class="stats">
      <span>Score: <strong id="score">0</strong></span>
      <span>Lives: <strong id="lives">3</strong></span>
      <span>Wave: <strong id="wave">1</strong></span>
    </div>
    <div class="badges">
      <div class="badge">← → move</div>
      <div class="badge">Space shoot</div>
      <div class="badge">R restart</div>
      <div class="badge">P pause</div>
    </div>
  </header>

  <main id="game">
    <canvas id="c" width="1280" height="800" aria-label="Game canvas"></canvas>
  </main>

  <footer>
    <div class="controls">
      <div class="touch-pad">
        <div></div>
        <div class="btn" data-hold="ArrowUp">▲</div>
        <div></div>
        <div class="btn" data-hold="ArrowLeft">◀</div>
        <div class="btn" data-tap="Space">●</div>
        <div class="btn" data-hold="ArrowRight">▶</div>
      </div>
      <div class="btn secondary" id="pauseBtn">Pause (P)</div>
      <div class="btn right" id="restartBtn">Restart (R)</div>
    </div>
    <div class="hint">Tip: Hitting multiple enemies quickly builds a combo for bonus points!</div>
  </footer>
</div>

<script>
(() => {
  // ---------- Utilities ----------
  const rand = (min, max) => Math.random() * (max - min) + min;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const now = () => performance.now();

  // ---------- Canvas / Context ----------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // ---------- UI elements ----------
  const scoreEl  = document.getElementById('score');
  const livesEl  = document.getElementById('lives');
  const waveEl   = document.getElementById('wave');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');

  // ---------- Game state ----------
  const STATE = {
    running: false,
    paused: false,
    last: 0,
    dt: 0,
    t: 0,
    width: canvas.width,
    height: canvas.height,
    input: { left:false, right:false, up:false, down:false, shoot:false },
    player: null,
    bullets: [],
    enemies: [],
    particles: [],
    score: 0,
    lives: 3,
    wave: 1,
    spawnTimer: 0,
    spawnInterval: 1.1,
    combo: 0,
    comboTimer: 0,
    comboWindow: 1.4, // seconds to chain hits
    gameOver: false,
  };

  // ---------- Entities ----------
  function createPlayer() {
    return {
      x: STATE.width / 2,
      y: STATE.height - 80,
      w: 42,
      h: 50,
      speed: 520,
      cooldown: 0,
      cooldownMax: 0.18,
      inv: 0,
    };
  }

  function spawnEnemy() {
    const kind = Math.random() < 0.75 ? 'basic' : (Math.random() < 0.5 ? 'zig' : 'tank');
    const w = kind === 'tank' ? 54 : 38;
    const h = kind === 'tank' ? 54 : 38;
    const e = {
      kind,
      x: rand(40, STATE.width - 40),
      y: -60,
      w, h,
      vy: kind === 'tank' ? rand(60, 90) : rand(110, 180),
      vx: kind === 'zig' ? rand(-80, 80) : 0,
      hp: kind === 'tank' ? 3 : 1,
      t: 0,
    };
    STATE.enemies.push(e);
  }

  function bullet(x, y, vx=0, vy=-780) {
    return { x, y, vx, vy, r: 4, life: 2.0 };
  }

  function particle(x, y, vx, vy, life, size, color) {
    return { x, y, vx, vy, life, maxLife: life, size, color };
  }

  // ---------- Input ----------
  const keys = new Set();
  const setInputFromKeys = () => {
    STATE.input.left  = keys.has('ArrowLeft') || keys.has('a') || keys.has('A');
    STATE.input.right = keys.has('ArrowRight')|| keys.has('d') || keys.has('D');
    STATE.input.up    = keys.has('ArrowUp')   || keys.has('w') || keys.has('W');
    STATE.input.down  = keys.has('ArrowDown') || keys.has('s') || keys.has('S');
    STATE.input.shoot = keys.has(' ') || keys.has('Space');
  };
  window.addEventListener('keydown', (e) => {
    if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown',' '].includes(e.key)) e.preventDefault();
    keys.add(e.key);
    if (e.key === 'p' || e.key === 'P') togglePause();
    if (e.key === 'r' || e.key === 'R') restart();
    setInputFromKeys();
  });
  window.addEventListener('keyup', (e) => {
    keys.delete(e.key);
    setInputFromKeys();
  });

  // Touch controls (mobile)
  function bindTouchButtons() {
    document.querySelectorAll('.touch-pad .btn').forEach(btn => {
      const holdKey = btn.dataset.hold;
      const tapKey = btn.dataset.tap;
      if (holdKey) {
        btn.addEventListener('pointerdown', () => { keys.add(holdKey); setInputFromKeys(); });
        btn.addEventListener('pointerup',   () => { keys.delete(holdKey); setInputFromKeys(); });
        btn.addEventListener('pointerleave',() => { keys.delete(holdKey); setInputFromKeys(); });
        btn.addEventListener('pointercancel',() => { keys.delete(holdKey); setInputFromKeys(); });
      }
      if (tapKey) {
        btn.addEventListener('pointerdown', () => { keys.add(tapKey); setInputFromKeys(); });
        btn.addEventListener('pointerup',   () => { keys.delete(tapKey); setInputFromKeys(); });
        btn.addEventListener('pointerleave',() => { keys.delete(tapKey); setInputFromKeys(); });
        btn.addEventListener('pointercancel',() => { keys.delete(tapKey); setInputFromKeys(); });
      }
    });
  }
  bindTouchButtons();

  pauseBtn.addEventListener('click', () => togglePause());
  restartBtn.addEventListener('click', () => restart());

  // ---------- Game flow ----------
  function start() {
    STATE.player = createPlayer();
    STATE.bullets.length = 0;
    STATE.enemies.length = 0;
    STATE.particles.length = 0;
    STATE.score = 0;
    STATE.lives = 3;
    STATE.wave = 1;
    STATE.spawnInterval = 1.1;
    STATE.spawnTimer = 0;
    STATE.combo = 0;
    STATE.comboTimer = 0;
    STATE.gameOver = false;
    STATE.paused = false;
    STATE.running = true;
    STATE.last = now();
    requestAnimationFrame(loop);
    updateHUD();
  }

  function restart() { start(); }
  function togglePause() {
    if (STATE.gameOver) return;
    STATE.paused = !STATE.paused;
    if (!STATE.paused) {
      STATE.last = now();
      requestAnimationFrame(loop);
    }
  }

  // ---------- Core Loop ----------
  function loop(ts) {
    if (!STATE.running) return;
    if (STATE.paused) return;
    const t = now();
    STATE.dt = Math.min(0.033, (t - STATE.last) / 1000); // clamp dt to 33ms
    STATE.last = t;
    STATE.t += STATE.dt;

    update(STATE.dt);
    draw();

    if (STATE.running && !STATE.paused) requestAnimationFrame(loop);
  }

  // ---------- Update ----------
  function update(dt) {
    const p = STATE.player;
    if (!STATE.gameOver) {
      // Movement
      let dx = 0, dy = 0;
      if (STATE.input.left)  dx -= 1;
      if (STATE.input.right) dx += 1;
      if (STATE.input.up)    dy -= 1;
      if (STATE.input.down)  dy += 1;
      const len = Math.hypot(dx, dy) || 1;
      p.x += (dx/len) * p.speed * dt;
      p.y += (dy/len) * (p.speed * 0.7) * dt;
      p.x = clamp(p.x, 30, STATE.width - 30);
      p.y = clamp(p.y, 80, STATE.height - 30);

      // Shooting
      p.cooldown -= dt;
      if (STATE.input.shoot && p.cooldown <= 0) {
        const spread = 10;
        STATE.bullets.push(bullet(p.x - 10, p.y - 24, 0, -820));
        STATE.bullets.push(bullet(p.x + 10, p.y - 24, 0, -820));
        // tiny side pebbles for flair
        STATE.bullets.push(bullet(p.x - 18, p.y - 24, -60, -760));
        STATE.bullets.push(bullet(p.x + 18, p.y - 24,  60, -760));
        p.cooldown = p.cooldownMax;
        muzzleFlash(p.x, p.y - 26);
      }

      // Combo decay
      if (STATE.combo > 0) {
        STATE.comboTimer -= dt;
        if (STATE.comboTimer <= 0) STATE.combo = 0;
      }

      // Spawning
      STATE.spawnTimer -= dt;
      if (STATE.spawnTimer <= 0) {
        spawnEnemy();
        STATE.spawnTimer = STATE.spawnInterval * (0.5 + Math.random() * 0.9);
      }
    }

    // Bullets
    for (let i = STATE.bullets.length - 1; i >= 0; i--) {
      const b = STATE.bullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.life -= dt;
      if (b.y < -20 || b.life <= 0) STATE.bullets.splice(i,1);
    }

    // Enemies
    for (let i = STATE.enemies.length - 1; i >= 0; i--) {
      const e = STATE.enemies[i];
      e.t += dt;
      if (e.kind === 'zig') {
        e.vx += Math.sin(e.t * 3.2) * 20 * dt;
      }
      e.x += e.vx * dt;
      e.y += e.vy * dt;

      // bounce sideways a bit
      if (e.x < 20 || e.x > STATE.width - 20) e.vx *= -1;

      // Off-screen -> remove and penalize (only if passes the player line)
      if (e.y > STATE.height + 40) {
        STATE.enemies.splice(i, 1);
        damagePlayer();
        continue;
      }

      // Collide with bullets
      for (let j = STATE.bullets.length - 1; j >= 0; j--) {
        const b = STATE.bullets[j];
        if (circleRectOverlap(b.x, b.y, b.r, e.x - e.w/2, e.y - e.h/2, e.w, e.h)) {
          STATE.bullets.splice(j, 1);
          e.hp -= 1;
          hitSpark(b.x, b.y);
          if (e.hp <= 0) {
            boom(e.x, e.y, e.kind);
            STATE.enemies.splice(i,1);
            addScore(100 + 25 * (STATE.wave - 1));
          }
          break;
        }
      }

      // Collide with player
      if (!STATE.gameOver && rectsOverlap(
          e.x - e.w/2, e.y - e.h/2, e.w, e.h,
          p.x - p.w/2, p.y - p.h/2, p.w, p.h)) {
        boom(e.x, e.y, e.kind);
        STATE.enemies.splice(i,1);
        damagePlayer(true);
      }
    }

    // Particles
    for (let i = STATE.particles.length - 1; i >= 0; i--) {
      const pt = STATE.particles[i];
      pt.x += pt.vx * dt;
      pt.y += pt.vy * dt;
      pt.life -= dt;
      if (pt.life <= 0) STATE.particles.splice(i,1);
    }

    // Difficulty ramp per wave
    const targetCount = 6 + STATE.wave * 2;
    if (!STATE.gameOver && STATE.enemies.length >= targetCount) {
      // when enough on screen, slightly slow spawns
      STATE.spawnInterval = Math.min(1.6, STATE.spawnInterval + 0.05);
    }
    // Progress wave when player clears most enemies for a few seconds
    if (!STATE.gameOver && STATE.t > 5 && STATE.enemies.length <= 2) {
      nextWave();
    }
  }

  // ---------- Collisions ----------
  function circleRectOverlap(cx, cy, r, rx, ry, rw, rh) {
    const closestX = clamp(cx, rx, rx + rw);
    const closestY = clamp(cy, ry, ry + rh);
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx*dx + dy*dy) <= r*r;
  }
  function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  // ---------- Effects ----------
  function muzzleFlash(x, y) {
    for (let i = 0; i < 6; i++) {
      STATE.particles.push(particle(
        x + rand(-3,3), y + rand(-4,1),
        rand(-40,40), rand(-130,-60),
        rand(0.08,0.16), rand(2,3), 'rgba(255,230,120,0.9)'));
    }
  }
  function hitSpark(x, y) {
    for (let i = 0; i < 7; i++) {
      STATE.particles.push(particle(
        x, y, rand(-160,160), rand(-160,160),
        rand(0.15,0.35), rand(1.5,2.5), 'rgba(170,200,255,0.9)'));
    }
  }
  function boom(x, y, kind='basic') {
    const count = kind === 'tank' ? 28 : 18;
    for (let i = 0; i < count; i++) {
      const spd = rand(120, 420);
      const a = rand(0, Math.PI*2);
      STATE.particles.push(particle(
        x, y, Math.cos(a)*spd, Math.sin(a)*spd,
        rand(0.3,0.9), rand(2,4), 'rgba(255,120,140,0.9)'));
    }
  }

  // ---------- Scoring & Lives ----------
  function addScore(base) {
    const bonus = STATE.combo > 0 ? Math.min(STATE.combo * 10, 200) : 0;
    STATE.score += base + bonus;
    STATE.combo += 1;
    STATE.comboTimer = STATE.comboWindow;
    if (STATE.score % 1200 < 150 && STATE.score > 0) {
      // small chance to award extra life near thresholds
      if (Math.random() < 0.04) {
        STATE.lives = Math.min(5, STATE.lives + 1);
        textFloat('1UP!', '#71ffb2');
      }
    }
    updateHUD();
  }

  function damagePlayer(heavy=false) {
    if (STATE.player.inv > 0 || STATE.gameOver) return;
    STATE.lives -= heavy ? 2 : 1;
    STATE.player.inv = 1.2; // seconds of invulnerability
    shake(8);
    if (STATE.lives <= 0) {
      STATE.lives = 0;
      gameOver();
    }
    updateHUD();
  }

  function nextWave() {
    STATE.wave++;
    STATE.spawnInterval = Math.max(0.55, 1.1 - STATE.wave * 0.06);
    textFloat(`WAVE ${STATE.wave}`, '#6cf');
    updateHUD();
  }

  function gameOver() {
    STATE.gameOver = true;
    textFloat('GAME OVER', '#ff5d73', 1.8);
  }

  function updateHUD() {
    scoreEl.textContent = STATE.score;
    livesEl.textContent = STATE.lives;
    waveEl.textContent  = STATE.wave;
  }

  // ---------- Screen shake ----------
  let shakeMag = 0, shakeTime = 0;
  function shake(mag=6, time=0.25) { shakeMag = mag; shakeTime = time; }

  // ---------- Floating text ----------
  const floatTexts = [];
  function textFloat(msg, color='#fff', life=1.2) {
    floatTexts.push({ msg, color, x: STATE.width/2, y: 110, life, maxLife: life });
  }

  // ---------- Draw ----------
  function draw() {
    // Background stars
    ctx.clearRect(0,0,STATE.width,STATE.height);
    drawStars();

    // Shake transform
    if (shakeTime > 0) {
      shakeTime -= STATE.dt;
      const s = shakeMag * (shakeTime / Math.max(shakeTime, 0.0001));
      ctx.save();
      ctx.translate(rand(-s,s), rand(-s,s));
    } else {
      ctx.save();
    }

    // Player
    drawPlayer();

    // Bullets
    ctx.fillStyle = '#aee3ff';
    for (const b of STATE.bullets) {
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fill();
    }

    // Enemies
    for (const e of STATE.enemies) drawEnemy(e);

    // Particles
    for (const p of STATE.particles) {
      const a = p.life / p.maxLife;
      ctx.globalAlpha = Math.max(a, 0);
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
      ctx.globalAlpha = 1;
    }

    // Floating texts
    for (let i = floatTexts.length - 1; i >= 0; i--) {
      const ft = floatTexts[i];
      ft.life -= STATE.dt;
      const a = Math.max(ft.life / ft.maxLife, 0);
      ctx.globalAlpha = a;
      ctx.fillStyle = ft.color;
      ctx.font = 'bold 42px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(ft.msg, ft.x, ft.y - (1 - a) * 30);
      ctx.globalAlpha = 1;
      if (ft.life <= 0) floatTexts.splice(i,1);
    }

    // Pause/game over overlays
    if (STATE.paused) {
      overlay('PAUSED • Press P to resume');
    } else if (STATE.gameOver) {
      overlay('GAME OVER • Press R to restart');
    }

    ctx.restore();

    // Player invulnerability timer tick after drawing (so the blink syncs)
    if (STATE.player.inv > 0) STATE.player.inv -= STATE.dt * 0.9;
  }

  // ---------- Drawing helpers ----------
  const starField = [...Array(220)].map(() => ({
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height,
    s: Math.random() * 1.8 + 0.2,
    v: Math.random() * 40 + 20
  }));
  function drawStars() {
    ctx.fillStyle = '#0a0e19';
    ctx.fillRect(0,0,STATE.width,STATE.height);
    for (const st of starField) {
      st.y += st.v * STATE.dt;
      if (st.y > STATE.height) { st.y = -2; st.x = Math.random() * STATE.width; }
      ctx.globalAlpha = clamp(st.s / 2.2, 0.2, 0.9);
      ctx.fillStyle = '#b7cfff';
      ctx.fillRect(st.x, st.y, st.s, st.s);
      ctx.globalAlpha = 1;
    }
  }

  function drawPlayer() {
    const p = STATE.player;
    const blink = p.inv > 0 ? (Math.sin(STATE.t * 20) > 0 ? 0.3 : 1) : 1;
    ctx.save();
    ctx.translate(p.x, p.y);

    // ship body
    ctx.globalAlpha = blink;
    roundedRect(-p.w/2, -p.h/2, p.w, p.h, 10, '#1b284d');
    roundedRect(-p.w/2+6, -p.h/2+10, p.w-12, p.h-18, 8, '#2c3f7a');
    // canopy
    roundedRect(-14, -p.h/2+8, 28, 20, 8, '#6cc7ff');
    // wings
    roundedRect(-p.w/2-10, -10, 18, 20, 6, '#203460');
    roundedRect(p.w/2-8, -10, 18, 20, 6, '#203460');
    // engine glow
    const glow = (Math.sin(STATE.t * 20) + 1) * 0.5;
    ctx.fillStyle = `rgba(120,220,255,${0.35+glow*0.25})`;
    ctx.beginPath();
    ctx.ellipse(0, p.h/2 - 4, 10, 8 + glow*3, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawEnemy(e) {
    ctx.save();
    ctx.translate(e.x, e.y);
    if (e.kind === 'basic') {
      roundedRect(-e.w/2, -e.h/2, e.w, e.h, 8, '#7b2b37');
      roundedRect(-e.w/2+6, -e.h/2+6, e.w-12, e.h-12, 6, '#a33b49');
    } else if (e.kind === 'zig') {
      roundedRect(-e.w/2, -e.h/2, e.w, e.h, 10, '#5a2b7b');
      ctx.rotate(Math.sin(e.t*8)*0.15);
      roundedRect(-e.w/2+6, -e.h/2+6, e.w-12, e.h-12, 8, '#7b3ba3');
    } else { // tank
      roundedRect(-e.w/2, -e.h/2, e.w, e.h, 6, '#6b3c16');
      roundedRect(-e.w/2+6, -e.h/2+6, e.w-12, e.h-12, 4, '#9a5a22');
      // tiny "rivets"
      ctx.fillStyle = 'rgba(255,255,255,0.25)';
      for (let i=0;i<4;i++) ctx.fillRect(-e.w/2+10+i*10, -e.h/2+10, 2, 2);
    }
    ctx.restore();
  }

  function roundedRect(x,y,w,h,r, fillStyle) {
    ctx.fillStyle = fillStyle;
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  function overlay(text) {
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.fillRect(0,0,STATE.width,STATE.height);
    ctx.fillStyle = '#e8ecff';
    ctx.textAlign = 'center';
    ctx.font = 'bold 64px system-ui, sans-serif';
    ctx.fillText(text, STATE.width/2, STATE.height/2);
    ctx.restore();
  }

  // ---------- Kick things off ----------
  start();
})();
</script>
</body>
</html>
